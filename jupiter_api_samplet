use serde::{Deserialize, Serialize};
use reqwest::Client;
use std::time::{Duration, Instant};
use anyhow::{Result, anyhow};
use log::{info, warn, error};
use std::sync::{Arc, Mutex};
use std::cmp::min;
use crate::solana::SolanaClient;
use crate::rate_limiter::RateLimiter;
use lazy_static::lazy_static;
use std::collections::HashMap;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TokenResponse {
    pub tokens: Vec<Token>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Token {
    pub address: String,
    pub symbol: String,
    pub name: String,
    pub decimals: u8,
    #[serde(default)]
    pub logo_uri: String,
    #[serde(default)]
    pub tags: Vec<String>,
    #[serde(default)]
    pub daily_volume: Option<f64>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Quote {
    #[serde(default)]
    #[serde(alias = "inputMint")]
    pub input_mint: String,
    #[serde(default)]
    #[serde(alias = "outputMint")]
    pub output_mint: String,
    #[serde(default)]
    #[serde(alias = "inAmount")]
    pub in_amount: String,
    #[serde(default)]
    #[serde(alias = "outAmount")]
    pub out_amount: String,
    #[serde(default)]
    #[serde(alias = "otherAmountThreshold")]
    pub other_amount_threshold: String,
    #[serde(default)]
    #[serde(alias = "swapMode")]
    pub swap_mode: String,
    #[serde(alias = "slippageBps")]
    pub slippage_bps: u64,
    #[serde(default)]
    #[serde(alias = "platformFee")]
    pub platform_fee: Option<PlatformFee>,
    #[serde(default)]
    #[serde(alias = "priceImpactPct")]
    pub price_impact_pct: String,
    #[serde(default)]
    #[serde(alias = "routePlan")]
    pub route_plan: Vec<RoutePlanInfo>,
    #[serde(default)]
    #[serde(alias = "contextSlot")]
    pub context_slot: u64,
    #[serde(default)]
    pub address_lookup_tables: Option<Vec<String>>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PlatformFee {
    pub amount: String,
    #[serde(alias = "feeBps")]
    pub fee_bps: u64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RoutePlanInfo {
    #[serde(alias = "swapInfo")]
    pub swap_info: SwapInfo,
    pub percent: u8,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SwapInfo {
    pub label: String,
    #[serde(alias = "ammKey")]
    pub amm_key: String,
    #[serde(alias = "inputMint")]
    pub input_mint: String,
    #[serde(alias = "outputMint")]
    pub output_mint: String,
    #[serde(alias = "inAmount")]
    pub in_amount: String,
    #[serde(alias = "outAmount")]
    pub out_amount: String,
    #[serde(alias = "feeAmount")]
    pub fee_amount: String,
    #[serde(alias = "feeMint")]
    pub fee_mint: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SwapTransaction {
    #[serde(rename = "swapTransaction")]
    pub swap_transaction: String,
    #[serde(rename = "lastValidBlockHeight", default)]
    pub last_valid_block_height: Option<u64>,
    #[serde(rename = "prioritizationFeeLamports", default)]
    pub prioritization_fee_lamports: Option<u64>,
    #[serde(rename = "computeUnitLimit", default)]
    pub compute_unit_limit: Option<u64>,
    #[serde(rename = "prioritizationType", default)]
    pub prioritization_type: Option<PrioritizationType>,
    #[serde(rename = "addressesByLookupTableAddress", default)]
    pub addresses_by_lookup_table_address: Option<serde_json::Value>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PrioritizationType {
    #[serde(rename = "computeBudget", default)]
    pub compute_budget: Option<ComputeBudget>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ComputeBudget {
    #[serde(default)]
    pub microlamports: Option<u64>,
    #[serde(rename = "estimatedMicroLamports", default)]
    pub estimated_microlamports: Option<u64>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DynamicSlippageReport {
    #[serde(rename = "slippageBps", default)]
    pub slippage_bps: Option<u64>,
    #[serde(rename = "otherAmount", default)]
    pub other_amount: Option<String>,
    #[serde(rename = "simulatedIncurredSlippageBps", default)]
    pub simulated_incurred_slippage_bps: Option<i64>,
    #[serde(rename = "amplificationRatio", default)]
    pub amplification_ratio: Option<String>,
    #[serde(rename = "categoryName", default)]
    pub category_name: Option<String>,
    #[serde(rename = "heuristicMaxSlippageBps", default)]
    pub heuristic_max_slippage_bps: Option<u64>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SimulationError {
    #[serde(rename = "errorCode")]
    pub error_code: String,
    pub error: String,
}

// Global counter for API requests across all threads
lazy_static! {
    static ref GLOBAL_REQUEST_COUNT: Arc<Mutex<u64>> = Arc::new(Mutex::new(0));
    static ref LAST_LOG_TIME: Arc<Mutex<Instant>> = Arc::new(Mutex::new(Instant::now()));
    static ref THREAD_REQUEST_COUNTS: Arc<Mutex<HashMap<usize, u64>>> = Arc::new(Mutex::new(HashMap::new()));
    static ref ENDPOINT_REQUEST_COUNTS: Arc<Mutex<HashMap<String, u64>>> = Arc::new(Mutex::new(HashMap::new()));
}

pub struct JupiterClient {
    client: Client,
    max_retries: u32,
    rate_limiter: Option<Arc<RateLimiter>>,
    solana_client: Option<Arc<SolanaClient>>,
    current_thread_id: Arc<Mutex<usize>>,
}

impl JupiterClient {
    pub fn new(max_retries: u32) -> Self {
        Self {
            client: Client::new(),
            max_retries,
            rate_limiter: None,
            solana_client: None,
            current_thread_id: Arc::new(Mutex::new(0)),
        }
    }
    
    // Helper method to get the Jupiter API key from environment
    fn get_api_key(&self) -> String {
        std::env::var("JUPITER_API_KEY").unwrap_or_else(|_| {
            warn!("JUPITER_API_KEY not found in environment, using default");
            "b5e5d25a-7897-47c2-a963-75975aa2c7dd".to_string()
        })
    }
    
    pub fn with_solana_client(mut self, solana_client: Arc<SolanaClient>) -> Self {
        self.solana_client = Some(solana_client);
        self
    }
    
    pub fn with_rate_limiter(mut self, rate_limiter: Arc<RateLimiter>) -> Self {
        self.rate_limiter = Some(rate_limiter);
        self
    }
    
    // Set the rate limit based on Jupiter API level
    pub fn set_rate_limit(&self, api_level: u64) {
        let rpm = match api_level {
            0 => 60,      // Free tier: 1 RPS / 60 RPM
            1 => 600,     // 10 RPS / 600 RPM
            2 => 3000,    // 50 RPS / 3000 RPM
            3 => 6000,    // 100 RPS / 6000 RPM
            4 => 30000,   // 500 RPS / 30000 RPM
            _ => 60,      // Default to free tier
        };
        
        // Pass the API level to the rate limiter if it exists
        if let Some(rate_limiter) = &self.rate_limiter {
                rate_limiter.set_api_level(api_level);
        }
        
        info!("Jupiter API rate limit set to {} requests per minute (Level {})", rpm, api_level);
    }
    
    // Add a method to set the current thread ID
    pub fn set_thread_id(&self, thread_id: usize) {
        let mut current_id = self.current_thread_id.lock().unwrap();
        *current_id = thread_id;
    }
    
    fn check_rate_limit(&self, endpoint: &str) -> Result<()> {
        // Update global counter for stats
        let mut global_count = GLOBAL_REQUEST_COUNT.lock().unwrap();
        *global_count += 1;
        
        // Update thread-specific counter
        let thread_id = *self.current_thread_id.lock().unwrap();
        let mut thread_counts = THREAD_REQUEST_COUNTS.lock().unwrap();
        *thread_counts.entry(thread_id).or_insert(0) += 1;
        
        // Update endpoint-specific counter
        let mut endpoint_counts = ENDPOINT_REQUEST_COUNTS.lock().unwrap();
        *endpoint_counts.entry(endpoint.to_string()).or_insert(0) += 1;
        
        // Log global stats every 1000 requests
        if *global_count % 1000 == 0 {
            let mut last_log = LAST_LOG_TIME.lock().unwrap();
            let elapsed = last_log.elapsed();
            let rate = 1000.0 / elapsed.as_secs_f64();
            
            info!("API request stats: {} total requests, {:.2} requests/second", 
                *global_count, rate);
            
            // Log thread distribution
            info!("Thread distribution:");
            for (tid, count) in thread_counts.iter() {
                let percentage = (*count as f64 / *global_count as f64) * 100.0;
                info!("  Thread {}: {} calls ({:.1}%)", tid, count, percentage);
            }
            
            // Log endpoint distribution
            info!("Endpoint distribution:");
            for (ep, count) in endpoint_counts.iter() {
                let percentage = (*count as f64 / *global_count as f64) * 100.0;
                info!("  {}: {} calls ({:.1}%)", ep, count, percentage);
            }
                
            *last_log = Instant::now();
        }
        
        // If we have a rate limiter, use it with the current thread ID and endpoint
        if let Some(rate_limiter) = &self.rate_limiter {
            let thread_id = *self.current_thread_id.lock().unwrap();
            if rate_limiter.is_limited() || !rate_limiter.increment_request_count_for_thread(thread_id, Some(endpoint)) {
                let time_to_wait = rate_limiter.get_current_delay();
                warn!("Rate limited by RateLimiter for thread {} on endpoint {}. Current delay: {}ms", 
                      thread_id, endpoint, time_to_wait);
                return Err(anyhow!("Rate limit exceeded. Try again later"));
            }
        }
        
        Ok(())
    }
    
    pub async fn get_quote(&self, input_mint: &str, output_mint: &str, amount: u64, slippage_bps: u64) -> Result<Quote> {
        let thread_id = *self.current_thread_id.lock().unwrap();
        
        // Check if we're in a backoff period
        if let Some(rate_limiter) = &self.rate_limiter {
            if rate_limiter.is_in_backoff(thread_id) {
                let delay = rate_limiter.get_backoff_delay();
                warn!("Thread {} in backoff period, waiting {}ms before fetching quote", thread_id, delay);
                tokio::time::sleep(Duration::from_millis(delay)).await;
            }
        }
        
        self.check_rate_limit("quote")?;
        
        let url = format!(
            "https://api.jup.ag/swap/v1/quote?inputMint={}&outputMint={}&amount={}&slippageBps={}",
            input_mint, output_mint, amount, slippage_bps
        );
        
        let api_key = self.get_api_key();
        
        let mut retries = 0;
        loop {
            // Build the request with API key
            let response = self.client
                .get(&url)
                .header("x-api-key", &api_key)
                .send()
                .await;

            match response {
                Ok(resp) => {
                    if resp.status().is_success() {
                        let response_text = resp.text().await?;
                        match serde_json::from_str::<Quote>(&response_text) {
                            Ok(quote) => {
                                let mut quote = quote;
                                if quote.input_mint.is_empty() {
                                    quote.input_mint = input_mint.to_string();
                                }
                                if quote.output_mint.is_empty() {
                                    quote.output_mint = output_mint.to_string();
                                }
                                return Ok(quote);
                            },
                            Err(e) => {
                                error!("Failed to parse quote response: {}", e);
                                error!("Response text: {}", &response_text);
                                if retries >= self.max_retries {
                                    return Err(anyhow!("Failed to parse API response after {} retries", retries));
                                }
                            }
                        }
                    } else {
                        let status = resp.status();
                        let error_text = resp.text().await.unwrap_or_default();
                        error!("API error: {} - {}", status, error_text);
                        
                        // Handle 429 rate limit errors specifically
                        if status.as_u16() == 429 {
                            error!("Rate limit (429) error received from Jupiter API");
                            
                            // Trigger exponential backoff via rate limiter
                            if let Some(rate_limiter) = &self.rate_limiter {
                                rate_limiter.handle_rate_limit_error(thread_id);
                                
                                // Wait for a short time before checking backoff status again
                                tokio::time::sleep(Duration::from_millis(500)).await;
                                continue;
                            } else {
                                // If no rate limiter, use a simple backoff
                                let backoff = 5 * 2u64.pow(retries as u32);
                                error!("No rate limiter configured, backing off for {}s", backoff);
                                tokio::time::sleep(Duration::from_secs(backoff)).await;
                            }
                        }
                        
                        if retries >= self.max_retries {
                            return Err(anyhow!("API error after {} retries: {}", retries, status));
                        }
                    }
                },
                Err(e) => {
                    error!("Request error: {}", e);
                    if retries >= self.max_retries {
                        return Err(anyhow!("Request failed after {} retries: {}", retries, e));
                    }
                }
            }
            
            retries += 1;
            
            // Exponential backoff for retries
            let backoff_ms = 500 * 2u64.pow(retries as u32).min(10000);
            tokio::time::sleep(Duration::from_millis(backoff_ms)).await;
        }
    }
    
    pub async fn fetch_trending_tokens(&self) -> Result<Vec<Token>> {
        let thread_id = *self.current_thread_id.lock().unwrap();
        
        // Check if we're in a backoff period
        if let Some(rate_limiter) = &self.rate_limiter {
            if rate_limiter.is_in_backoff(thread_id) {
                let delay = rate_limiter.get_backoff_delay();
                warn!("Thread {} in backoff period, waiting {}ms before fetching tokens", thread_id, delay);
                tokio::time::sleep(Duration::from_millis(delay.min(delay))).await;
            }
        }
        
        self.check_rate_limit("tokens")?;
        
        let url = "https://tokens.jup.ag/tokens?tags=birdeye-trending";
        
        let api_key = self.get_api_key();
        
        let mut retries = 0;
        loop {
            match self.client.get(url)
                .header("x-api-key", &api_key)
                .send()
                .await {
                Ok(response) => {
                    if response.status().is_success() {
                        let response_text = response.text().await?;
                        info!("API Response: {}", &response_text[..min(200, response_text.len())]);
                        
                        match serde_json::from_str::<TokenResponse>(&response_text) {
                            Ok(token_response) => {
                                return Ok(token_response.tokens);
                            },
                            Err(e) => {
                                error!("Failed to parse token response: {}", e);
                                match serde_json::from_str::<Vec<Token>>(&response_text) {
                                    Ok(tokens) => {
                                        return Ok(tokens);
                                    },
                                    Err(e2) => {
                                        error!("Failed to parse as Vec<Token>: {}", e2);
                                        if retries >= self.max_retries {
                                            return Err(anyhow!("Failed to parse API response"));
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        let status = response.status();
                        let error_text = response.text().await.unwrap_or_default();
                        error!("API error: {} - {}", status, error_text);
                        
                        // Handle 429 rate limit errors specifically
                        if status.as_u16() == 429 {
                            error!("Rate limit (429) error received from Jupiter API");
                            
                            // Trigger exponential backoff via rate limiter
                            if let Some(rate_limiter) = &self.rate_limiter {
                                rate_limiter.handle_rate_limit_error(thread_id);
                                
                                // Wait for a short time before checking backoff status again
                                tokio::time::sleep(Duration::from_millis(500)).await;
                                continue;
                            } else {
                                // If no rate limiter, use a simple backoff
                                let backoff = 5 * 2u64.pow(retries as u32);
                                error!("No rate limiter configured, backing off for {}s", backoff);
                                tokio::time::sleep(Duration::from_secs(backoff)).await;
                            }
                        }
                        
                        if retries >= self.max_retries {
                            return Err(anyhow!("API error after {} retries: {}", retries, status));
                        }
                    }
                },
                Err(e) => {
                    error!("Request error: {}", e);
                    if retries >= self.max_retries {
                        return Err(anyhow!("Request failed after {} retries: {}", retries, e));
                    }
                }
            }
            
            retries += 1;
            
            // Exponential backoff for retries
            let backoff_ms = 500 * 2u64.pow(retries as u32).min(10000);
            tokio::time::sleep(Duration::from_millis(backoff_ms)).await;
        }
    }
    
    pub fn get_usdc_token() -> Token {
        Token {
            address: "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v".to_string(),
            symbol: "USDC".to_string(),
            name: "USD Coin".to_string(),
            decimals: 6,
            logo_uri: "https://raw.githubusercontent.com/solana-labs/token-list/main/assets/mainnet/EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v/logo.png".to_string(),
            tags: vec!["stablecoin".to_string()],
            daily_volume: None,
        }
    }
    
    pub fn get_wsol_token() -> Token {
        Token {
            address: "So11111111111111111111111111111111111111112".to_string(),
            symbol: "SOL".to_string(),
            name: "Wrapped SOL".to_string(),
            decimals: 9,
            logo_uri: "https://raw.githubusercontent.com/solana-labs/token-list/main/assets/mainnet/So11111111111111111111111111111111111111112/logo.png".to_string(),
            tags: vec!["wrapped-solana".to_string()],
            daily_volume: None,
        }
    }

}
